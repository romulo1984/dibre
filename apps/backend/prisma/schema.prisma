// dib.re - Database schema
// MySQL for local (Docker) and production (Coolify env)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum Role {
  admin   // backoffice futuro
  member  // usuário logado normal (cria peladas/jogadores, faz sorteios)
  viewer  // legado / somente leitura
}

enum GroupRequestStatus {
  pending
  accepted
  declined
}

enum NotificationType {
  GROUP_JOIN_REQUEST
  GROUP_INVITATION
}

model User {
  id        String   @id @default(cuid())
  clerkId   String   @unique
  email     String?
  name      String?
  role      Role     @default(member)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  games    Game[]
  players  Player[]

  ownedGroups           Group[]           @relation("GroupOwner")
  groupMemberships      GroupMember[]
  groupJoinRequests     GroupJoinRequest[]
  sentInvitations       GroupInvitation[] @relation("InvitedBy")
  receivedInvitations   GroupInvitation[] @relation("InvitedUser")
  sentNotifications     Notification[]    @relation("NotificationSender")
  receivedNotifications Notification[]    @relation("NotificationRecipient")
}

model Player {
  id          String    @id @default(cuid())
  name        String
  avatarUrl   String?   @db.MediumText // URL ou data URL (base64) da foto/avatar
  stars       Int       // 1-5 overall level
  pass        Int       // 1-5
  shot        Int       // 1-5
  defense     Int       // 1-5
  energy      Int       // 1-5
  speed       Int       // 1-5
  createdById String?
  createdBy   User?     @relation(fields: [createdById], references: [id], onDelete: SetNull)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime? // soft delete
  participations GamePlayer[]
  @@index([createdById])
}

model Game {
  id            String    @id @default(cuid())
  name          String
  numberOfTeams Int       // 2, 3, etc.
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  deletedAt     DateTime? // soft delete
  createdById   String?
  createdBy     User?     @relation(fields: [createdById], references: [id], onDelete: SetNull)
  groupId       String?   // optional: if set, visible to group members
  group         Group?    @relation(fields: [groupId], references: [id], onDelete: SetNull)
  players       GamePlayer[]
  teams         Team[]
  @@index([createdById])
  @@index([groupId])
}

model GamePlayer {
  id        String   @id @default(cuid())
  gameId    String
  game      Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  playerId  String
  player    Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  @@unique([gameId, playerId])
  @@index([gameId])
  @@index([playerId])
}

model Team {
  id            String   @id @default(cuid())
  gameId        String
  game          Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  name          String   // e.g. "Time A", "Time B"
  order         Int      // 1, 2, 3...
  playerIds     Json     // JSON array of player IDs for this team
  avgStars      Float?
  avgPass       Float?
  avgShot       Float?
  avgDefense    Float?
  avgEnergy     Float?
  avgSpeed      Float?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  @@index([gameId])
}

// ── Groups ──────────────────────────────────────────────────────────────────

model Group {
  id          String    @id @default(cuid())
  name        String
  description String?   @db.Text
  slug        String    @unique
  ownerId     String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  owner         User              @relation("GroupOwner", fields: [ownerId], references: [id])
  members       GroupMember[]
  joinRequests  GroupJoinRequest[]
  invitations   GroupInvitation[]
  notifications Notification[]
  games         Game[]

  @@index([ownerId])
}

model GroupMember {
  id       String   @id @default(cuid())
  groupId  String
  userId   String
  joinedAt DateTime @default(now())

  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@index([groupId])
  @@index([userId])
}

model GroupJoinRequest {
  id        String             @id @default(cuid())
  groupId   String
  userId    String
  status    GroupRequestStatus @default(pending)
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt

  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@index([groupId])
  @@index([userId])
}

model GroupInvitation {
  id              String             @id @default(cuid())
  groupId         String
  invitedUserId   String
  invitedByUserId String
  status          GroupRequestStatus @default(pending)
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt

  group       Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  invitedUser User  @relation("InvitedUser", fields: [invitedUserId], references: [id], onDelete: Cascade)
  invitedBy   User  @relation("InvitedBy", fields: [invitedByUserId], references: [id], onDelete: Cascade)

  @@unique([groupId, invitedUserId])
  @@index([groupId])
  @@index([invitedUserId])
}

// ── Notifications ────────────────────────────────────────────────────────────

model Notification {
  id         String           @id @default(cuid())
  type       NotificationType
  toUserId   String
  fromUserId String
  groupId    String?
  relatedId  String?          // ID of the related request or invitation
  message    String
  read       Boolean          @default(false)
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt

  toUser   User   @relation("NotificationRecipient", fields: [toUserId], references: [id], onDelete: Cascade)
  fromUser User   @relation("NotificationSender", fields: [fromUserId], references: [id], onDelete: Cascade)
  group    Group? @relation(fields: [groupId], references: [id], onDelete: SetNull)

  @@index([toUserId])
  @@index([fromUserId])
}
